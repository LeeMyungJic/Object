## 3장



###### 2장에서는...

- 클래스, 추상 클래스, 인터페이스를 조합하여 객체지향 프로그램을 구조화하는 기본적인 방법과 상속을 이용해 다형성을 구현하는 기법 소개
- 다형성은 지연 바인딩 메커니즘을 통해 구현
- 캡슐화 측면에서는 상속보다 합성이 더 좋은 방법
- 유연한 객체지향을 위해 컴파일 시간 의존성과 실행 시간 의존성이 달라야 함



###### 협력

- 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용

- 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단

- 메시지를 수신한 객체는 메소드를 실행해 요청에 응답

  > Screening은 Movie에 calculateMovieFee 메시지를 전송함으로써 예매자 한 명의 요금 계산을 요청
  >
  > 요금 계산과 관련 정보를 잘 알고 있는 것이 Movie이기 때문에 Screening이 Movie에게 위임
  >
  > 만약 위임하지 않고 직접 처리한다면 Movie의 인스턴스 변수인 fee와 discountPolicy에 직접 접근해야 함 - 이 경우 Screening은 Movie의 내부 구현에 결합됨 - Movie의 자율성 훼손
  >
  > 결과적으로 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것 - 즉, Screening이 직접 처리하는 것은 캡슐화에 위반!

- 자율적인 객체는 할당된 책임을 수행하던 중 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송하여 협력 요청

- 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 함

- 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기 제공

- 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력

  >Movie의 행동을 결정하는 것은 영화 예매를 위한 협력
  >
  >객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동
  >
  >객체는 수행하는 행동에 필요한 상태도 함께 가지고 있어야 함
  >
  >Q. 행동과 상태란 ?
  >
  >Movie가 기본 요금인 fee와 할인 정책인 discountPolicy라는 인스턴스 변수를 상태의 일부로 포함하는 이유는 요금 계산이라는 행동을 수행하는 데 이 정보들이 필요하기 때문
  >
  >~~~ Movie
  >public class Movie {
  >	private Money fee;
  >	private DefaultDiscountPolicy discountPolicy;
  >	
  >	public Money calculateMovieFee(Screening screening) {
  >        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
  >    }
  >}
  >~~~
  >
  >즉, 상태는 객체가 행동하는 데 필요한 정보에 의해 결정. 행동은 협력 안에서 객체가 처리할 메시지로 결정. 결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두 결정
  >
  > 협력은 객체를 설계하는 데 필요한(객체에게 할당할 책임을 결정할 수 있는) 일종의 문맥(context) 제공 !



###### 책임

- 객체가 협력에 참여하기 위해 수행하는 로직(행동)

- 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로 더 큼

- 객체의 책임 : 객체가 '무엇을 알고 있는가'와 '무엇을 할 수 있는가'로 구성

- 크레이그 라만(Craig Larman)

  > 하는 것
  >
  > - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
  > - 다른 객체의 행동을 시작시키는 것
  > - 다른 객체의 활동을 제어하고 조절하는 것
  >
  > 아는 것
  >
  > - 사적인 정보에 관해 아는 것
  > - 관련된 객체에 관해 아는 것
  > - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
  >
  > > Screening의 책임 : 영화를 예매하는 것(하는 것) , 자신의 영화를 알아야 할 것(아는 것)
  > >
  > > Movie의 책임 : 요금을 계산하는 것(하는 것), 어떤 정책이 적용 되었는지(아는 것)
  > >
  > > 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정
  >
  > 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 SW 객체에 할당 하는 것

- CRC 카드

  > Candidate(후보), Responsiblity(책임), Collaborator(협력자)
  >
  > >예시
  > >
  > >상단 : Screening → 후보 
  > >
  > >좌하단 : 상영 정보를 알고 있다, 예매 정보를 생성한다 → 책임
  > >
  > >우하단 : Movie → 협력자
  >
  > 일반적으로 추상적이고 가상적인 것보다는 구체적이고 실재적인 것을 사용하는 경향이 있음
  >
  > CRC 카드는 역할을 식별하고, 책임을 할당하며, 협력을 명시적으로 표현하는 구체적이면서도 실용적인 기법이기 때문에 다이어그램 대신 CRC를 사용

- 책임 할당

  > INFORMATION EXPERT (정보 전문가 패턴)
  >
  > - 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것
  >
  > 따라서 객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의
  >
  > 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것
  >
  > > 시스템이 사용자에게 제공해야 할 기능은 영화를 예매하는 것이고 이 기능을 시스템이 제공할 책임으로 할당
  > >
  > > 책임을 수행하게 하는 유일한 방법은 메시지 전송 - 책임을 할당하는 것은 메시지의 이름을 결정하는 것과 같음
  > >
  > > 1: 예매하라
  > >
  > > 메시지를 처리할 적절한 객체 선택. 정보 전문가에게 책임을 할당. 따라서 영화에 관한 정보를 가장 많이 알고 있는 Screening 객체를 선택
  > >
  > > 영화를 예매하기 위해 가격을 계산해야 함. 하지만 Screening은 가격 계산에 필요한 정보를 충분히 알고있지 않음. 이것은 외부 객체에게 가격 계산을 요청해야 한다는 것을 의미하므로 새로운 메시지가 필요하다.
  > >
  > > 2: 가격을 계산하라
  > >
  > > 마찬가지로 가격을 계산하는데 필요한 정보(가격과 할인정책)를 가장 많이 알고있는 정보 전문가인 Movie를 선택. - Movie에게 가격을 계산할 책임을 부여
  > >
  > > 가격을 계산하기 위해서는 할인 요금이 필요하지만 Movie는 요금 계산하는 데 적정한 정보 전문가가 아니므로 '할인 요금을 계산하라'라는 새로운 메시지를 발견
  > >
  > > ...
  > >
  > > 이처럼 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄지고, 이런 메시지가 메시지를 수신할 객체의 책임을 결정

- 책임 주도 설계 (Responsibility-Dreven Design, RDD)

  - 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법

  - 위의 예시는 책임 주도 설계 방법에서 제시하는 기본적인 흐름을 따른 것

    > - 시스템이 사용자에게 제공해야 하는 기능인 시스템을 파악한다.
    >
    > - 시스템 책임을 더 작은 책임으로 분할한다.
    >
    > - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
    >
    > - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
    >
    > - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.



###### 메시지가 객체를 결정한다

- 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택

- 메시지가 객체를 선택하게 해야 하는 두 가지 이유

  > - 객체가 최소한의 인터페이스를 가질 수 있게 된다.
  >
  >   > 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 크지도, 작지도 않은 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있음
  >
  > - 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.
  >
  >   > 객체의 인터페이스는 무엇(What)을 하는지 표현해야 하지만 어떻게(How) 수행하는지를 표현하면 안 됨
  >   >
  >   > 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있음



###### 행동이 상태를 결정한다

- 객체가 존재하는 이유는 협력에 참여하기 위함이므로, 객체는 협력에 필요한 행동을 제공해야 함

- 객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동

  > 상태에 초점을 맞추면 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해
  >
  > 객체의 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경되고, 결국 객체에 의존하면 클라이언트로 변경의 영향이 전파
  >
  > 이러한 설계(객체 내부 구현에 초점을 맞춘)를 데이터 주도 설계(Data-Driven Disign)이라 함
  >
  > 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이라고 생각



###### 역할

- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 것


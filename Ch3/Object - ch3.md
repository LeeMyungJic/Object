## 3장



###### 2장에서는...

- 클래스, 추상 클래스, 인터페이스를 조합하여 객체지향 프로그램을 구조화하는 기본적인 방법과 상속을 이용해 다형성을 구현하는 기법 소개
- 다형성은 지연 바인딩 메커니즘을 통해 구현
- 캡슐화 측면에서는 상속보다 합성이 더 좋은 방법
- 유연한 객체지향을 위해 컴파일 시간 의존성과 실행 시간 의존성이 달라야 함



###### 협력

- 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용

- 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단

- 메시지를 수신한 객체는 메소드를 실행해 요청에 응답

  > Screening은 Movie에 calculateMovieFee 메시지를 전송함으로써 예매자 한 명의 요금 계산을 요청
  >
  > 요금 계산과 관련 정보를 잘 알고 있는 것이 Movie이기 때문에 Screening이 Movie에게 위임
  >
  > 만약 위임하지 않고 직접 처리한다면 Movie의 인스턴스 변수인 fee와 discountPolicy에 직접 접근해야 함 - 이 경우 Screening은 Movie의 내부 구현에 결합됨 - Movie의 자율성 훼손
  >
  > 결과적으로 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것 - 즉, Screening이 직접 처리하는 것은 캡슐화에 위반!

- 자율적인 객체는 할당된 책임을 수행하던 중 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송하여 협력 요청

- 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 함

- 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기 제공

- 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력

  >Movie의 행동을 결정하는 것은 영화 예매를 위한 협력
  >
  >객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동
  >
  >객체는 수행하는 행동에 필요한 상태도 함께 가지고 있어야 함
  >
  >Q. 행동과 상태란 ?
  >
  >Movie가 기본 요금인 fee와 할인 정책인 discountPolicy라는 인스턴스 변수를 상태의 일부로 포함하는 이유는 요금 계산이라는 행동을 수행하는 데 이 정보들이 필요하기 때문
  >
  >~~~ Movie
  >public class Movie {
  >	private Money fee;
  >	private DefaultDiscountPolicy discountPolicy;
  >	
  >	public Money calculateMovieFee(Screening screening) {
  >        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
  >    }
  >}
  >~~~
  >
  >즉, 상태는 객체가 행동하는 데 필요한 정보에 의해 결정. 행동은 협력 안에서 객체가 처리할 메시지로 결정. 결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두 결정
  >
  > 협력은 객체를 설계하는 데 필요한(객체에게 할당할 책임을 결정할 수 있는) 일종의 문맥(context) 제공 !



###### 책임

- 객체가 협력에 참여하기 위해 수행하는 로직(행동)

- 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로 더 큼

- 객체의 책임 : 객체가 '무엇을 알고 있는가'와 '무엇을 할 수 있는가'로 구성

- 크레이그 라만(Craig Larman)

  > 하는 것
  >
  > - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
  > - 다른 객체의 행동을 시작시키는 것
  > - 다른 객체의 활동을 제어하고 조절하는 것
  >
  > 아는 것
  >
  > - 사적인 정보에 관해 아는 것
  > - 관련된 객체에 관해 아는 것
  > - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
  >
  > > Screening의 책임 : 영화를 예매하는 것(하는 것) , 자신의 영화를 알아야 할 것(아는 것)
  > >
  > > Movie의 책임 : 요금을 계산하는 것(하는 것), 어떤 정책이 적용 되었는지(아는 것)
  > >
  > > 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정
  >
  > 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 SW 객체에 할당 하는 것




- CRC 카드

  > Candidate(후보), Responsiblity(책임), Collaborator(협력자)
  >
  > >예시
  > >
  > >상단 : Screening → 후보 
  > >
  > >좌하단 : 상영 정보를 알고 있다, 예매 정보를 생성한다 → 책임
  > >
  > >우하단 : Movie → 협력자
  >
  > 일반적으로 추상적이고 가상적인 것보다는 구체적이고 실재적인 것을 사용하는 경향이 있음
  >
  > CRC 카드는 역할을 식별하고, 책임을 할당하며, 협력을 명시적으로 표현하는 구체적이면서도 실용적인 기법이기 때문에 다이어그램 대신 CRC를 사용




- 책임 할당

  > INFORMATION EXPERT (정보 전문가 패턴)
  >
  > - 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것
  >
  > 따라서 객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의
  >
  > 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것
  >
  > > 시스템이 사용자에게 제공해야 할 기능은 영화를 예매하는 것이고 이 기능을 시스템이 제공할 책임으로 할당
  > >
  > > 책임을 수행하게 하는 유일한 방법은 메시지 전송 - 책임을 할당하는 것은 메시지의 이름을 결정하는 것과 같음
  > >
  > > 1: 예매하라
  > >
  > > 메시지를 처리할 적절한 객체 선택. 정보 전문가에게 책임을 할당. 따라서 영화에 관한 정보를 가장 많이 알고 있는 Screening 객체를 선택
  > >
  > > 영화를 예매하기 위해 가격을 계산해야 함. 하지만 Screening은 가격 계산에 필요한 정보를 충분히 알고있지 않음. 이것은 외부 객체에게 가격 계산을 요청해야 한다는 것을 의미하므로 새로운 메시지가 필요하다.
  > >
  > > 2: 가격을 계산하라
  > >
  > > 마찬가지로 가격을 계산하는데 필요한 정보(가격과 할인정책)를 가장 많이 알고있는 정보 전문가인 Movie를 선택. - Movie에게 가격을 계산할 책임을 부여
  > >
  > > 가격을 계산하기 위해서는 할인 요금이 필요하지만 Movie는 요금 계산하는 데 적정한 정보 전문가가 아니므로 '할인 요금을 계산하라'라는 새로운 메시지를 발견
  > >
  > > ...
  > >
  > > 이처럼 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄지고, 이런 메시지가 메시지를 수신할 객체의 책임을 결정

  

- 책임 주도 설계 (Responsibility-Dreven Design, RDD)

  - 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법

  - 위의 예시는 책임 주도 설계 방법에서 제시하는 기본적인 흐름을 따른 것

    > - 시스템이 사용자에게 제공해야 하는 기능인 시스템을 파악한다.
    >
    > - 시스템 책임을 더 작은 책임으로 분할한다.
    >
    > - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
    >
    > - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
    >
    > - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.



###### 메시지가 객체를 결정한다

- 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택

- 메시지가 객체를 선택하게 해야 하는 두 가지 이유

  > - 객체가 최소한의 인터페이스를 가질 수 있게 된다.
  >
  >   > 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 크지도, 작지도 않은 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있음
  >
  > - 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.
  >
  >   > 객체의 인터페이스는 무엇(What)을 하는지 표현해야 하지만 어떻게(How) 수행하는지를 표현하면 안 됨
  >   >
  >   > 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있음



###### 행동이 상태를 결정한다

- 객체가 존재하는 이유는 협력에 참여하기 위함이므로, 객체는 협력에 필요한 행동을 제공해야 함

- 객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동

  > 상태에 초점을 맞추면 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해
  >
  > 객체의 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경되고, 결국 객체에 의존하면 클라이언트로 변경의 영향이 전파
  >
  > 이러한 설계(객체 내부 구현에 초점을 맞춘)를 데이터 주도 설계(Data-Driven Disign)이라 함
  >
  > 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이라고 생각



###### 역할

- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 것

  > 객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 됨
  >
  > 객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시됨
  >
  > 실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각
  >
  > > 앞에서 '예매하라'라는 메시지를 처리하기에 적합한 객체로 Screening을 선택
  > >
  > > 하나의 단계처럼 보였지만 실제로는 두 개의 독립적인 단계가 합쳐진 것 !
  > >
  > > - 첫 번째 단계 : 영화를 예매할 수 있는 적절한 역할이 무엇인가 찾는 것
  > >
  > >   Q. 객체를 수용할 수 있는 위치로서 역할이라는 개념이 존재한다는데, '예매하라' 라는 메시지와 역할의 차이 ?
  > >
  > > - 두 번째 단계 : 역할을 수행할 객체로 Screening 인스턴스 선택
  > >
  > > 역할에 특별한 이름을 부여한 것은 아니지만 실제로는 익명의 역할을 찾고, 그 역할을 수행할 수 있는 객체를 선택하는 방식으로 설계가 진행되었다고 생각하는 것이 자연스러움

  

- 유연하고 재사용 가능한 협력

  - 역할이 중요한 이유는 역할을 통해 재사용 가능한 협력을 얻을 수 있기 때문

    > 역할의 개념을 고려하지 않고 객체에게 책임을 할당한다고 가정해보자
    >
    > Movie가 가격을 계산하기 위해 할인 요금이 필요하므로 '할인 요금을 계산하라'라는 메시지를 외부 객체에 전송하여 도움을 요청한다.
    >
    > 할인 정책에는 AmountDiscountPolicy와 PercentDiscountPolicy라는 두 가지 종류의 객체가 존재하기 때문에 두 객체 모두 '할인 요금을 계산하라'라는 메시지에 응답할 수 있어야 한다.
    >
    > 그렇다면 두 객체가 참여하는 협력을 개별적으로 만들어야 할까 ?
    >
    > 이런 방법으로 두 협력을 구현하면 대부분의 코드가 중복됨 - 코드 중복은 문제의 근원이므로 피해야 함
    >
    > 객체가 아니라 순수하게 책임의 관점에서 바라보면 두 객체 모두 할인 요금 계산이라는 동일한 책임을 수행한다는 것을 알 수 있다. 따라서 메시지에 응답할 수 있는 대표자(여기서는 DiscountPolicy)를 생각한다면 두 협력을 하나로 통합이 가능. 이 대표자를 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯으로 생각한다면 그 슬롯이 바로 역할이다.
    >
    > Q.  여기서 말하는 슬롯이 필요한 상황에 맞는 객체를 1개만 꽃을 수 있는 그런 슬롯인지? 예를 들어 도시를 선택하는 스피너가 있을때 아무것도 선택하지 않으면 '도시를 선택하세요'이고 선택을 하면 '인천'으로 바뀌는 것처럼 ?
    >
    > - 결과적으로 불필요한 중복 코드를 제거하고, 협력이 더 유연해짐
    >
    >   (DiscountPolicy 역할을 수행할 수 있는 어떤 객체라도 이 협력에 참여 가능)
    >
    > - 역할의 구현
    >
    >   > 역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 사용하는 것.
    >   >
    >   > 협력의 관점에서 추상 클래스와 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한 것.
    >   >
    >   > - 추상 클래스 : 책임의 일부를 구현해 놓은 것
    >   > - 인터페이스 : 일체의 구현 없이 책임의 집합만을 나열해 놓은 것
    >   > - 협력의 관점에서는 둘 모두 역할을 정의할 수 있는 구현 방법이라는 공통점을 공유
    >   >
    >   > 역할이 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체들의 타입을 캡슐화하는 추상화라는 것이 중요
    >   >
    >   > 객체에게 중요한 것은 행동. 역할은 객체를 추상화해서 객체 자체가 아닌 협력에 초점을 맞출 수 있게 함
    >   >
    >   > Q. 그러면 88p 맨 아래에 DiscountPolicy 역할을 수행하는 객체는 2개가 아니라 NoneDiscountPolicy를 추가한 3개 ? 맞다면 표시도 세 객체 모두 표시해야 하나?

    

- 객체 대 역할 

  - 역할은 객체가 참여할 수 있는 일종의 슬롯.

  - 레베카 워프스브록

    > 만약 동일한 종류의 객체가 하나의 역할을 항상 수행한다면 둘은 동일. 하지만 어떤 협력에서 하나 이상의 객체가 동일한 책임을 수행할 수 있다면 역할은 서로 다른 방법으로 실행할 수 있는 책임의 집합이 됨.

    - 협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주

    - 만약 여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 됨

      Q. '예매하라'라는 책임을 수행하는 대상은 Screening 한 종류로 객체로 간주하고, '할인 요금을 계산하라'라는 책임을 수행하는 대상은 3가지이기 때문에 역할이라고 부름?

  - 트리그비 린스카우

    > 협력을 역할들의 상호작용으로 구성
    >
    > 렵력을 구성하기 위해 역할에 적합한 객체가 선택됨
    >
    > 객체는 클래스를 이용해 구현되고 생성됨

  - 협력은 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용이 가능해짐

  - 역할의 가장 큰 장점은 설계의 구성 요소를 추상화할 수 있다는 것

  

- 역할과 추상화

  - 2장에서의 추상화의 장점

    - 추상화 계층만을 이용하면 중요 정책을 상위 수준에서 단순화 가능
    - 설계가 유연해짐

  - 역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화라고 볼 수 있음. 따라서 추상화가 가지는 두 가지 장점이 역할에서도 적용

  - 협력이라는 관점에서는 세부적인 사항을 무시하고 추상화에 집중하는 것이 유용

    > 세부 사항(할인 정책과 할인 조건)을 무시하고 DiscountPolicy와 DiscountCondition만 바라보면 상황을 추상화할 수 있음
    >
    > 결과적으로 흐름을 더 쉽게 파악할 수 있으며, 객체 사이의 핵심적인 상호작용이 좀 더 또렷하게 드러나게 됨
    >
    > 여기서 DiscountPolicy와 DiscountCondition이 바로 역할!

    

- 배우와 배역

  > 배우는 연극이 상영될 때 배역이라는 특정한 역할을 연기한다.
  >
  > = 객체는 협력이라는 실행 문맥 안에서 특정한 역할을 수행한다.
  >
  > 연극이 끝나면 자신의 배역을 잊고 원래 자기 자신을 되찾는다.
  >
  > = 협력이 끝나고 협력에서의 역할을 잊고 객체로 돌아올 수 있다.
  >
  > 하나의 배역을 여러 배우가 연기할 수 있다.
  >
  > = 역할을 수행하는 하나 이상의 객체들이 존재할 수 있다.
  >
  > 여러 연극에 참여하면서 여러 배역을 연기할 수 있다.
  >
  > = 여러 협력에 참여하면서 다양한 역할을 수행할 수 있다.
  >
  > 하나의 연극에서 하나의 배역을 연기한다.
  >
  > = 특정한 협력 안에서 일시적으로 오직 하나의 역할만이 보여진다.
  >
  > 
  >
  > - 일반적으로 역할은 객체가 협력에 참여하는 잠시 동안에만 존재하는 일시적인 것
  > - 역할은 모양이나 구조에 의해 정의될 수 없으며, 오직 시스템의 문맥 안에서 무엇을 하는지에 의해서만 정의될 수 있음
  > - 객체는 다양한 역할을 가질 수 있으며, 협력에 참여할 대 협력 안에서 하나의 역할로 보여짐
  > - 다른 협력에 참여할 때에는 다른 역할로 보여짐




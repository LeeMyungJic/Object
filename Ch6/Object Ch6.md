## 6장

###### 협력과 메시지

- 클라이언트-서버 모델

  - 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포

  - 클라이언트 : 협력 안에서 메시지를 전송하는 객체

  - 서버 : 메시지를 수신하는 객체

  - 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용

  - Screening과 Movie

    - Screening은 Movie에 '가격을 계산하라'라는 메시지 전송 - 클라이언트
    - Movie는 가격을 계산하는 서비스를 제공 - 서버

  - Movie와 DiscountPolicy

    - Movie는 DiscountPolicy에 '할인 요금을 계산하라'라는 메시지 전송 - 클라이언트
    - DiscountPolicy는 할인 요금을 계산하는 서비스 제공 - 서버

  - 이처럼 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적

  - 협력의 관점에서 메시지

    - 객체가 수신하는 메시지의 집합
    - 외부의 객체에게 전송하는 메시지의 집합

    

- 메시지와 메시지 전송

  - 메시지 : 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단

    - 오퍼레이션명
    - 인자
    - 여기에 메시지 수신자를 추가하면 메시지 전송

  - 메시지 전송(메시지 패싱) : 한 객체가 다른 객체에게 도움을 요청하는 행위

    - 오퍼레이션명, 인자, 메시지 수신자의 조합

  - 메시지 전송자 : 클라이언트

  - 메시지 수신자 : 서버

    ~~~java
    condition.isSatisfiedBy(screening);
    // condition : 수신자
    // isSatisfiedBy : 오퍼레이션명
    // screening : 인자
    ~~~

    ~~~objective-c
    [condition isSatisfiedBy: screening]
    ~~~

  

- 메시지와 메소드

  - 메소드 : 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저

    - 기술적인 관점에서 객체 사이의 메시지 전송은 전통적인 방식의 함수 호출이나 프로시저 호출과는 다름

    - 전통적인 방식의 개발자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 호출 구문 작성

      -> 코드의 의미가 컴파일 시점과 실행 시점에 동일

    - 객체는 메시지와 메소드라는 두 가지 서로 다른 개념을 실행 시점에 연결

      -> 컴파일 시점과 실행 시점의 의미가 달라질 수 있음

    - 실행 시점에 메시지와 메소드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성 가능하게 함

- 퍼블릭 인터페이스와 오퍼레이션

  - 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합

  - 오퍼레이션 : 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지

    - 수행 가능한 어떤 행동에 대한 추상화
    - 즉, 객체가 다른 객체에게 제공하는 추상적인 서비스
    - 메시지가 전송자와 수신자 사이의 협력관계를 강조하는데 비해 오퍼레이션은 메시지를 수신하는 객체의 인터페이스를 강조
    - 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는게 대부분
    - DiscountCondition 인터페이스에 정의된 isSatisfiedBy가 오퍼레이션에 해당

  - 메소드 : 메시지에 응답하기 위해 실행되는 코드 블록

    - 오퍼레이션의 구현

    - SequenceCondition과 PeriodCondition에 정의된 각각의 isSatisfiedBy는 실제 구현을 포함하기 때문에 메소드라 부름

      >UML은 공식적으로 오퍼레이션을 다음과 같이 정의한다.
      >
      >오퍼레이션이란 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세. UML 용어로 말하자면, 인터페이스의 각 요소는 오펴레이션. 
      >
      >오퍼레이션은 구현이 아닌 추상화. 반면 UML의 메소드는 오퍼레이션을 구현한 것. 즉, 메소드는 오펴레이션에 대한 구현

    - 프로그래밍 언어의 관점에서 객체가 다른 객체에게 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석

    - 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메소드를 실행

    - 따라서 퍼블릭 인터페이스와 메시지의 관점에서 보면 '메소드 호출'보다는 '오퍼레이션 호출'이라는 용어를 사용하는 것이 더 적절

    Q. 다형성을 도와주는(?) 과정(파라미터에 따라 적절한 메소드 실행)을 오퍼레이션 호출을 통해 하는 것입니까? 

- 시그니처

  - 오퍼레이션(또는 메소드)의 이름과 파라미터 목록을 합친 것
  - 오펴레이션은 실행 코드 없이 시그니처만을 정의한 것
  - 메소드는 오퍼레이션 + 구현
  - 일반적으로 메시지를 수신하면 오퍼레이션은 시그니처와 동일한 메소드 실행
  - 하나의 오퍼레이션에 대해 오직 하나의 메소드만 존재하면 굳이 오퍼레이션과 메소드를 구분할 필요가 없음 
  - 오퍼레이션 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메소드들이 실행되는 것

- 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정



###### 인터페이스와 설계 품질

- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 함

  - 최소한 : 꼭 필요한 오퍼레이션만을 인터페이스에 추가
  - 추상적인 : 어떻게 수행하는지가 아닌 무엇을 하는지를 포함

- 책임 주도 설계 

  - 메시지를 먼저 선택하므로 협력과 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지 -> 최소한의

  - 객체가 메시지를 선택하는 것이 아닌 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현 가능 -> 추상적인

    

- 디미터 법칙

  - 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙

  - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것

    > "낯선 자에게 말하지 말라"
    >
    > "오직 인접한 이웃하고만 말하라"
    >
    > 자바나 C# 등 '도트(.)'를 이용해 메시지 전송을 표현하는 언어에서는 "오직 하나의 도트만 사용하라" 라는 말로 요약되기도 함

  - 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 하라

    - this 객체
    - 메소드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소

    ~~~ java
    public class ReservationAgency {
        public Reservation reserve(Screening screening, ... ) {
            // ReservationAgency는 메소드의 인자로 전달된 Screening 인스턴스에게만 메시지 전송. Screening내부에 대한 어떤 정보도 알지 못함
            Money fee = screening.calculateFee(...);
            return new Reservation(...);
        }
    }
    ~~~

    - ReservationAgency가 Screening의 내부 구조에 결합돼 있지 않기 때문에 Screening의 내부 구현을 변경할 때 ReservationAgency를 함께 변경할 필요 없음

  - 디비터 법칙을 따르면 부끄럼타는 코드(shy code) 작성 가능

    - 불필요한 어떤 것도 다른 객체에게 보여주지 않음
    - 메시지 전송자는 메시지 수신자의 내부 구현에 결합되지 않음
    - 따라서 클라이언트와 서버 사이에 낮은 결합도 유지 가능

  - 디미터 법칙 위반

    - 흔히 기차 충돌이라 부름

    - 클래스의 내부 구현이 외부로 노출될 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 됨 -> 캡슐화 위반 및 높은 결합도

      ~~~ java
      // 기차 충돌 코드
      screening.getMovie().getDiscountCondisitons();
      // 개선
      screening.calculateFee(audienceCount);
      ~~~

      


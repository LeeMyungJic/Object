## 7장



###### 인지 과부하

- 문제를 해결하기 위해 사용하는 저장소는 단기 기억
- 필요한 정보들을 먼저 단기 기억 안으로 불러들여야 함
- 하지만 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격히 저하
- 그러므로 인지 과부하를 방지하는 가장 좋은 방법은 단기 기억 안에 보관할 정보 양을 조절하는 것
- 추상화 : 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
- 분해 : 큰 문제를 해결 가능한 작은 문제로 나누는 작업
- 조지 밀러의 매직 넘버 7
  - 정보의 가장 작은 단위로서의 개별 항목을 의미하는 것이 아니라 하나의 단위로 취급될 수 있는 논리적인 청크를 의미
  - 임의로 조합된 11자리 정수 8개를 한번에 기억하는 것은 어렵지만, 전화번호라는 개념적 청크로 묶는다면 8명에 대한 전화번호를 기억할 수 있도록 인지능력 향상 가능



#### 프로시저 추상화와 데이터 추상화

- 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지를 추상화
  - 프로시저 추상화 중심으로 시스템을 분해하기로 결정했다면 기능 분해(알고리즘 분해)의 길로 들어서는 것
- 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지를 추상화
  - 데이터 추상화 중심으로 시스템을 분해하기로 결정했다면 다시 두 가지 중 하나를 결정해야 함
  - 추상 데이터 타입 : 데이터를 중심으로 타입을 추상화
  - 객체지향 : 데이터를 중심으로 프로시저를 추상화
    - 기능을 '협력하는 공동체'를 구성하도록 객체들로 나누는 과정이 바로 객체지향 패러다임에서 분해를 의미
    - 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것!
- 소프트웨어는 데이터를 이용해 정보를 표현하고, 프로시저를 이용해 데이터를 조작
- 프로그래밍 패러다임 : 적절한 추상화의 윤곽을 따라 시스템을 어떤식으로 나눌 것인지를 결정하는 원칙과 방법의 집합



#### 프로시저 추상화와 기능 분해

 ###### 메인 함수로서의 시스템

- 기능 분해의 관점에서 추상화의 단위는 프로시저. 시스템은 프로시저를 단위로 분해됨

- 프로시저 : 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 기법

  - 내부의 상세한 구현 내용을 모르더라도 인터페이스를 알면 프로시저를 사용할 수 있기 때문에 프로시저를 추상화라고 부름

- 프로시저 중심의 기능 분해 관점에서 시스템은 입력 값을 계산해서 출력 값을 반환하는 수학의 함수와 동일

  - 시스템은 필요한 더 작은 작업으로 분해될 수 있는 하나의 커다란 메인 함수

- 전통적인 기능 분해 방법은 하향식 접근법(Top-Down Approach)

  - 시스템을 구성하는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법

  - 각 세분화 단계는 바로 위 단계보다 더 구체적이어야 함 

    = 정제된 기능은 자신의 바로 상위 단계보다 덜 추상화적이어야 함

  - 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해됨



###### 급여 관리 시스템

- 최상위의 추상적인 함수 정의는 시스템의 기능을 표현하는 하나의 문장으로 나타내고, 

  이 문장을 구성하는 좀 더 세부적인 단계의 문장으로 분해해 나가는 방식을 따르자

  ~~~ 
  최상위 : '직원의 급여를 계산한다'
  ~~~

- 급여를 계산하는 데 필요한 정보는 직원의 이름과 소득세율.

  ~~~ 
  직원의 급여를 계산한다
  	사용자로부터 소득세율을 입력받는다
  	직원의 급여를 계산한다
  	양식에 맞게 결과를 출력한다
  ~~~

- 각 정제 단계는 이전 문장의 추상화 수준을 감소시켜야 함

  -> 모든 문장이 정제 과정을 거치면서 하나 이상의 좀 더 단순하고 구체적인 문장들의 조합으로 분해돼야 함

- 직원의 급여를 계산하기 위해 소득세율뿐만 아니라 직원의 기본급 정보 역시 필요

  ~~~
  직원의 급여를 계산한다
  	사용자로부터 소득 세율을 입력받는다 // 책으로 따지면 목차 1
  		"세율을 입력하세요 : "라는 문장을 화면에 출력한다
  		키보드를 통해 세율을 입력받는다
  	직원의 급여를 계산한다 // 목차 2
  		전역 변수에 저장된 직원의 기본급 정보를 얻는다
  		급여를 계산한다
  	양식에 맞게 결과를 출력한다 // 목차 3
  		"이름 : {직원명}, 급여 : {계산된 금액}" 형식에 따라 출력 문자열을 생성한다
  ~~~

- 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것

  -> 책의 목차를 정리하고 그 안에 내용을 채워 넣는 것과 유사!

- 기능 분해에서는 기능을 중심으로 필요한 데이터를 결정

- 기능이 우선이고 데이터는 기능의 뒤를 따름

- 기능 분해를 위한 하향식 접근법은 먼저 필요한 기능을 생각하고, 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별



###### 급여 관리 시스템 구현

~~~ruby
# 급여 관리 시스템 : 직원의 급여를 계산한다

# (B) 에 필요한 직원의 목록, 직원별 기본급
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

# 직원에 대한 정보를 찾기 위해 필요한 직원의 이름은 함수의 인자로 받음
def main (name)
    
    # (A) 사용자로부터 소득 세율을 입력 받는다
    taxRate = getTaxRate()
    # (B) 직원의 급여를 계산한다
    pay = calculatePayFor(name, taxRate)
    # (C) 양식에 맞게 결과를 출력한다
    puts(describeResult(name, pay))
    
    # (A)
    def getTaxRate()
        # "세율을 입력하세요 : " 라는 문장을 화면에 출력한다
        print("세율을 입력하세요 : ")
        # 키보드를 통해 세율을 입력받는다
        return gets().chomp().to_f()
    end
    
    # (B)
    def calculatePayFor(name, taxRate)
        index = $employees.index(name)
        basePay = $basePays[index]
        return basePay - (basePay * taxRate)
    end
    
    # (C)
    def describeResult(name, pay)
        return "이름 : #{name}, 급여 : #{pay}"
    end
       
end
~~~

- 하향식 기능 분해 방식으로 설계한 시스템은 메인 함수를 루트로 하는 '트리'로 표현 가능



###### 하향식 기능의 문제점

- 문제점 파악

  - 시스템은 하나의 메인 함수로 구성돼 있지 않다
  - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다
  - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
  - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다
  - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다

- 하나의 메인 함수라는 비현실적인 아이디어

  - 대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않음

  - 모든 기능들은 규모라는 측면에서 차이가 있을 수는 있겠지만, 기능성의 측면에서는 동등하게 독립적이고 완결된 하나의 기능을 표현

  - 하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합

    하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않음

- 메인 함수의 빈번한 재설계

  - 하나의 메인 함수를 유일한 정상으로 간주하는 하향식 기능 분해의 경우 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 함

  - 모든 직원들의 기본급의 총합을 구하는 기능을 추가해 달라는 새로운 요구사항이 생겼다고 가정

    ~~~ ruby
    def sumOfBaePays
        result = 0
        for basePay in $basePays
            result += basePay
        end
        puts(result)
    end
    ~~~

    - 구현 자체만 보면 전역 변수에 저장돼 있는 직원들의 모든 기본급을 더하기만 하면 간단한 작업
    - 하지만 메인함수의 목적은 직원 각각의 급여를 계산하는 것이므로 이 로직이 들어설 자리가 마땅치 않음
    - 현재의 코드에서 sumOfBasePays 함수와 main 함수는 개념적으로 동등한 수준의 작업을 수행하므로 main 함수에서 sumOfBasePays 함수를 호출 불가
    - main 함수 안의 로직 전체를 calculatePay라는 함수로 추출한 후 main 함수에서 적절하게  sumOfBasePays 함수와 calculatePay 함수를 호출하게 해서 해결

    ~~~ruby
    def calculatePay (name)    
        taxRate = getTaxRate()
        pay = calculatePayFor(name, taxRate)
        puts(describeResult(name, pay))    
    end
    ~~~

    ~~~ruby
    def main(operation, args={})
        case(operation)
            when :pay then calculatePay(args[:name])
            when :basePays then sumOfBasePays()
        end
    end
      
    # main 호출 예시        
    main(:basePays)
    main(:pay, name:"직원A")        
    ~~~

    - 시스템은 여러 개의 정상으로 구성되기 때문에 새로운 정상을 추가할 때마다 하나의 정상이라고 생각했던 함수의 내부 구현을 수정할 수 밖에 없음

    - 결과적으로 빈번한 수정으로 인해 버그 발생 확률이 높아짐에 따라 시스템은 변경에 취약해 짐

      

- 비즈니스 로직과 사용자 인터페이스의 결합

  - 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요
  - "사용자로부터 소득세율을 입력받아 급여를 계산한 후 계산된 결과를 화면에 출력한다"
    - 급여를 계산하는 중요한 비즈니스 로직과 관련된 관심사와 세율을 입력받아 결과를 화면에 출력한다는 사용자 인터페이스의 관심사가 한 곳에 섞여있음
    - 결과적으로 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합됨
  - 사용자 인터페이스는 시스템 내에서 가장 자주 변경되는 부분
  - 비즈니스 로직은 그에 비해 변경이 적게 발생
  - 하지만 두 로직이 밀접하게 결합되어 있으므로 사용자 인터페이스 변경 시 비즈니스 로직까지 변경에 영향

- 성급하게 결정된 실행 순서

  - 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 만듦
  - 즉, 처음부터 구현을 염두해 두기 때문에 자연스럽게 함수들의 실행 순서를 정의하는 시간 제약을 강조
    - 소득세율을 입력받고, 그 후에 급여를 계산, 계산된 결과를 이용해 결과 출력
    - 실행 순서가 정해져있음 
  - 실행 순서나 조건, 반복과 같은 제어 구조를 미리 결정하지 않고는 분해를 진행할 수 없기 때문에 기능 분해 방식은 중앙집중 제어 스타일의 형태를 띨 수 밖에 없음
    - 자주 변경되는 시간적인 제약에 대한 미련을 버리고 좀 더 안정적인 논리적 제약을 설계의 기준으로 삼아서 해결
    - 객체지향은 함수 간의 호출 순서가 아니라 논리적 관계를 중심으로 설계를 이끌어 나감
  - 재사용의 어려움
    - 재사용이라는 개념은 일반성이라는 의미를 포함 -> 상위 함수보다 더 일반적이어야 함
    - 하지만 하향식 접근법을 따르면, 분해된 하위 함수는 항상 상위 함수보다 문맥에 더 종속적
    - 이것은 정확하게 재사용성과 반대되는 개념
  - 모든 문제의 원인은 결합도
    - 함수는 상위 함수가 강요하는 문맥에 강하게 결합됨
    - 함수는 함께 절차를 구성하는 다른 함수들과 시간적으로 강하게 결합돼 있음



- 데이터 변경으로 인한 파급효과

  - 하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어려움

    - 따라서 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어려움
    - 의존성과 결합도의 문제

  - 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 함

    - 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고, 외부에서는 제공되는 함수만 이용해 데이터에 접근해야 함

    - 즉, 잘 정의된 퍼블릭 인터페이스를 통해데이터에 대한 접근을 통제해야 함 !

      

- 언제 하향식 분해가 유용한가?

  - 하향식 아이디어는 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이
  - 이미 해결된 알고리즘을 문서화하고 서술하는 데는 훌륭한 기법
  - 하지만 실제로 동작하는 커다란 소프트웨어를 설계하는 데 적합한 방법은 아님



#### 모듈

###### 정보 은닉과 모듈

- 정보 은닉

  - 시스템을 모듈 단위로 분해하기 위한 기본 원리로 
  - 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심
  - 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리
    - 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 함
    - 모듈 분해 : 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정
    - 비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스 구현 가능
  - 모듈은 두 가지 비밀을 감춰야 함
    - 복잡성 : 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공하여 모듈의 복잡도를 낮춤
    - 변경 가능성 : 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 ㄱ설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공
  - 비밀이 반드시 데이터일 필요는 없으며, 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수도 있음
    - 시스템의 가장 일반적인 비밀은 데이터
    - 이 관점에서 데이터 캡슐화와 정보 은닉을 혼동스럽게 만듦
    - 데이터 캡슐화 
      - 데이터와 메소드를 하나의 단위로 통합하고 퍼블릭 메소드를 통해서만 접근을 허용

  ~~~ ruby
  # 지금까지 전역변수였던 employees 등이 모듈 내부로 옮겨짐
  # 외부에서는 Employees 모듈이 제공하는 퍼블릭 인터페이스에 포함된 함수를 통해서만 내부 변수 조작
  # 외부에서는 모듈 내부에 어떤 데이터가 존재하는지 알지 못함
  
  module Employees
      $employees = ["직원A", "직원B", ... ,"직원E"]
      $basePays = [400, 300, ... , 1.5]
      $hourlys = [false, false, ... , true]
      $timeCards = [0, 0, ... , 120]
      
      def Employss.calculatePay(name, taxRate)
          ...            
      def Employees.hourly?(name)
          ...
      def Employees.calculateHourlyPayFor(name, taxRate)
          ...
      def Employees.calculatePayFor(name, taxRate)
          ...
  	def Emloyees.sumOfBasePays()
          ...
    
  ~~~

  ~~~ruby
  # main 함수가 Employees 모듈의 기능을 사용하도록 코드 수정
  
  def main(operation, args={})
      ...
      end
  
  def calculatePay(name)
      ...
      pay = Employees.calculatePay(name, taxRate)
  end
  
  ...
      
  def sumOfBasePays()
      puts(Employees.sumOfBasePays())
  end
  ~~~



###### 모듈의 장점과 한계 (정리가 잘 안되요 Help !!!!!!!!!!!)

- 모듈의 장점
  - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미침
  - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리
  - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염 방지
    - 모듈의 한 가지 용도는 네임스페이스를 제공하는 것
    - 변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동등한 이름 사용 가능
    - 전역 네임스페이스의 오염 방지와 이름 충돌 위험 완화

- 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 함
  - 높은 응집도 유지 : 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합
  - 낮은 결합도 유지 : 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신
- 모듈의 가장 큰 단점은 인스턴스의 개념을 제공하지 않는다는 점
  - Employees 모듈은 단지 회사에 속한 모든 직원의 정보를 가지고 있는 모듈일 뿐
  - 좀 더 높은 수준의 추상화를 위해서는 직원 전체가 아니라 개별 직원을 독립적 단위로 다룰 수 있어야 함
  - 다수의 직원 인스턴스가 존재하는 추상화 메커니즘이 필요하다는 소리
  - 이를 만족하기 위해 등장한 개념이 바로 추상 데이터 타입


















































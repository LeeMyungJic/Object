[ch1]

로버트 글래스
이론보다 실무가 먼저
실무가 어느정도 발전하고 난 뒤에야 이론이 서서히 모습을 갖추고
해당 분야가 충분히 성숙해지는 시점에서 이론이 실무를 추월

로버트 마틴
모듈이 가져야하는 세가지 기능(목적)
(모듈 - 크기와 상관없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소)
1. 실행 중에 제대로 동작하는 것 // 모든 모듈의 존재 이유! 

2. 변경을 위해 존재 
// 대부분 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로 변경이 가능해야 함. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 함

3. 코드를 읽는 사람과 의사소통하는 것
// 모듈은 특별한 훈련 없이 개발자가 쉽게 읽고 이해가 가능해야 함. 의사소통할 수 없는 모듈은 개선

목표 : 앱 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성 제거

객체 사이의 의존성이 과한 경우를 가리켜 결합도가 높다고 한다.
객체 사이 결합도가 높다 - 객체 하나가 변경되면 같이 변경해야 할 확률이 높다
개선 - 객체를 자율적인 존재로 만들어!
캡슐화 : 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감춤
// 변경하기 쉬운 객체를 만드는 것! 
극장은 티켓판매소 안에 티켓 셀러가 존재한다는 것을 모른다. 단지 티켓 셀러가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고있다.

응집도 : 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 함
// 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮추며 응집도를 높일 수 있다. 외부 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만들자!

절차지향(ProCedural Programming)
 - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
 // 변경 전 극장의 enter()는 프로세스이고, 관객과 판매원, 가방, 판매소는 데이터.
프로세스인 극장이 4개의 데이터에 의존하고 있다! 
절차지향적 설계는 프로세스가 필요한 모든 데이터에 의존하고 있으므로 변경에 취약

객체지향(Object Oriented Programming)
데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍
// 흔히 데이터와 프로세스를 하나의 단위로 통합해 놓은 방식으로 표현
// 객체가 어떤 데이터를 가지느냐보다는 객체에 어떤 책임을 할당할 것인가에 초점
// 변경에 유연하게 대응할 수 있는 코드 - 이해하기 쉬운 코드
// 단순히 데이터와 프로세스를 객체라는 덩어리 안으로 밀어 넣었다고 해서 변경하기 쉬운 설계를 얻는 것이 아님. 앱은 객체로 구성. 앱의 기능은 객체들 간의 상호작용을 통해 구현. 상호작용은 객체 간 주고 받는 메시지로 표현

훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로 객체 사이의 결합도를 낮추는 것

트레이드 오프 : 어느 것을 얻으려면 반드시 다른 것을 희생하여야 하는 경제 관계.

두 방식 사이 근본적인 차이를 만드는 것이 책임의 이동
// 객체지향에서는 책임이 집중돼 있는 것

레베카 워프스브록은 이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화라고 부른다.
// 비록 현실에서는 수동적인 존재라도 객체지향 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀜

Java의 일정하지 않은 개수의 파라미터 
public class Test{

	public static void main(String[] args) {
	        TestClass tc= new TestClass(); 
	        tc.test("test1","test2","test3");
	}

}

class TestClass{
    public void test(String... strs) {

    	System.out.println(strs[0]);// test1
    	System.out.println(strs[1]); // test2
        
    }	
}

[ch2]

영화 예매 시스템

** 요구사항
 - 할인조건(할인 여부) : 순서 조건(ex 10번째 상영 영화 할인), 기간 조건(요일, 시작 시간, 종료 시간)
 - 할인정책(할인 요금 결정) : 금액 할인 정책, 비율 할인 정책

객체지향
 - 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요할지 생각 !
    // 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화 한것. 
 - 객체들은 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 생각 !
    // 객체란 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재

도매인 
 - 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

객체지향 패러다임이 강하다 ?? - 객체지향의 중요성이나 의존성이 높은 이유인가 ??
 // 일단 그 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는  동일한 추상화 기법을 사용할 수 있기 때문

41p
할인정책 - 영화 
0..1 // 할인정책이 있을수도 있고 없을수도 있어서 ?
할인정책 - 할인조건 
1..* ?? // 아~ 할인 정책이 존재하면 무조건 한 개 이상의 할인 조건이 존재하기 때문

네이밍
일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 함
// 그냥 영화라는 개념은 영어로 Movie이어서 이렇게 지은거 ?
// 그러니까.. 대응되는 도메인 개념의 이름이란게 영화고 클래스가 Movie ?

훌륭한 클래스 설계의 핵심!
 - 어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정
 // Screening에서 알 수 있는 것처럼 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고, 
    적절한 public 메소드를 통해서만 내부 상태를 변경할 수 있게 해야 한다. 
 // 이처럼 내.외부를 구분하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문
 // 더 중요한 이유는 프로그래머에게 구현의 자유를 제공하기 때문!

자율적인 객체
 - 객체가 상태와 행동을 함께 가지는 복합적인 존재
 - 객체가 스스로 판단하고 행동하는 자율적인 존재

 이전 패러다임에서는 데이터와 기능이라는 독립적인 존재를 서로 엮어 프로그램 구성 
 // 데이터 클래스와 기능 클래스가 따로라는 소리 ?
 일단 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음. // 캡슐화 !!
 대부분의 객체지향 프로그래밍 언어들은 접근 수정자(access modifier)를 통해 접근 제어(access control)

 객체지향의 핵심은 스스로 상태를 관리, 판단, 행동하는 자율적인 객체들의 공동체를 구성하는 것
 // 외부에서는 객체가 어떤 상태인지, 어떤 생각을 하고 있는지 알아서 안 되며, 결정에 직접적으로
   개입하려 해서도 안 된다.

 캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.
 - 인터페이스 : 외부에서 접근 가능한 부분
 - 구현(implementation) : 외부에서는 접근 불가능. 오직 내부에서만 접근 가능한 부분
 // 인터페이스와 구현의 분리 ? 

 일반적으로 객체는 상태를 숨기고 행동만 외부에 공개, 속성은 구현에 포함

프로그래머의 자유 

 프로그래머 역할
 - 클래스 작성자(Class Creator) : 새로운 데이터 타입을 프로그램에 추가
    // 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 함 
    // 구현 은닉 (implementation hiding)
 - 클라이언트 프로그래머 : 클래스 작성자가 추가한 데이터 타입을 사용
    // 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축시켜야 함

 접근제어 메커니즘은 프로그래밍 언어 차원에서 클래스의 내부와 외부를 명확하게 경계 지을 수 있게
 하는 동시에, 클래스 작성자가 내부 구현을 은닉할 수 있게 해줌
 // 클라이언트 프로그래머가 private 속성이나 메서드에 접근하려고 시도하면 컴파일러는 오류 출력 ^^

 구현은닉의 사용
 C.P는 내부의 구현은 무시하고 인터페이스만  알고 있어도 클래스 사용 가능 - 알아야 할 지식의 양 감소
 C.C는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 수정 가능
 // public 영역을 수정하지 않는다면 코드를 자유롭게 수정 가능
 // 그러니까 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야겠지?

 설계가 필요한 이유는 변경을 관리하기 위함
 객체지향 언어는 객체 사이의 의존성을 적절히 관리하여 변경에 대한 파급효과 제어
 // 변경 관리 기법 중 하나가 접근 제어

개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의
명확성과 유연성을 높이는 첫 걸음 !
 // 1장에서는 가격을 위해 long을 사용하여 구현 관점의 제약은 표시할 수 있지만, Money 타입처럼
   저장하는 값이 금액과 관련돼 있다는 의미를 전달할 수 없다.
 // 말 그대로 우리가 아는 Long은 변수의 크기나 연산자의 종류 등과 관련하여 쓰인다는 것은 알 수 있지만 Long만 보고는 Money 처럼 관련된 실질적인 정보가 금액과 관련되어 있다는 것을 알 수 없다는 소리 ??

48p
 그림 2.5 숫자들은 그냥 흐름의 순서 ?

협력
 - 객체의 내부 상태는 숨기지만, 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있도록
 - 요청(request) : 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청
 - 응답(response) : 요청 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답을 보냄
 // 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송 뿐
    메시지를 수신한 객체는 스스로의 결정에 따라 장ㄹ적으로 메시지를 처리할 방법 결정
    이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메소드라 함
     // 메소드의 구분에서 부터 다형성의 개념이 출발 !
     // 메소드를 호출한다 - 메시지를 전송한다 

50p
 Movie 클래스에는 할인 정책을 판단하는 코드가 없다. discountPolicy에 메시지만 전송할 뿐이다.
 // 해당 코드에 상속과 다형성이 포함되어 있다. 그 기반에는 추상화(abstraction)라는 원리가 숨겨져 있다.

51p
 asList ?
 부모 클래스 : DiscountPolicy // 여기에 중복 코드 둠
 부모 클래스를 AmountDiscountPolicy와 PercentDiscountPolicy가 상속받음
 실제 앱에선 DiscountPolicy의 인스턴스를 생성할 필요가 없어 추상 클래스로 구현 
 // 음.. 할인정책에 메시지를 보낸 클래스는 할인 가격만 리턴 받으면 된다.. 어떤 정책, 어떤 조건을 만족시켰는지 알 필요 x. 근데 이건 은닉 아닌가.. 은닉 안에 추상화 기법?
 하나의 할인 정책은 여러개의 할인 조건을 포함 가능하다 했으니 List를 사용 ?
 getDiscountAmount는 protected네 ? 리턴 타입 Money인데 리턴 값이 없다. 나는 혼란스럽다
 52p에 설명이 있다! 
 다른 패키지에 있어서 vs 오버라이딩 해야해서 protected ?

52p
 TEMPLATE METHOD 패턴 (GOF94) : 부모 클래스에 기본적인 알고리즘의 흐름 구현. 중간에 처리를 자식 클래스에 위임하는 디자인 패턴
 // DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 제공하지만, 실제로 요금을 계산하는 부분은 추상 메소드인 getDiscountAmount 메소드에 위임 !

DiscountCondition 은 인터페이스로 되어있군. SequenceC 와 PeriodC는 그 인터페이스를 implements. (구현)

일단 혼란을 정리해보자.
SequenceC 와 PeriodC는 각자의 조건에 해당하면 부울린 값을 전달. SequenceC 와 PeriodC 중 하나라도 해당되는지를 판단하면 되기 때문에 DiscountCondition 인터페이스를 사용하여 true / false 만 전달.
어.. DiscountPolicy는 최종적으로 할인 조건에 해당하는 것이 하나라도 있는지만 확인하면 됨.

53p
 AmountDiscountPolicy.. DiscountPolicy의 getDiscountAmount 메소드를 오버라이딩하네!
 할인 금액은 discountAmount에 저장!
 할인 조건에 맞는 가격을 할인해야 해서 할인 조건을 오버라이딩 ?
 그런데 super가 뭘까 ㅎㅎ
 Percent.D.P 역시 getDiscountAmount 메소드 오버라이딩

오버라이딩 vs 오버로딩
 - 오버라이딩 : 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메소드를 자식 클래스에서 재정의
   // 자식 클래스의 메소드는 오버라이딩한 부모 클래스의 메소드를 가리기 때문에 외부에서는 부모 클래스가 보이지 않음.
 - 오버로딩 : 메소드의 이름은 같지만, 제공되는 파라미터 목록이 다름. 오버로딩한 메소드는 원래의 메소드를 가리지 않기 때문에 이 메소드들은 사이좋게 공존.. ??? 사이좋게 공존??
 아~~ 1장 중 Money에서 하나는 Money 타입을, 하나는 long 타입의 파라미터를 받도록 정의. 둘 다 메소드 이름은  plus로 같다! Bag에서 초대장이 있으면 Invitation invitation, long amount 없으면 null, long amount 인것도 같은 이유인가!

제약을 강제한다? 
이게 왜 오직 하나의 DiscountPolicy 인스턴스만 받을 수 있는겨
DiscountPolicy는 ... 으로 여러개를 받고 여기선 아니라.. 그런 소리인가? 나도 내가 뭔소리하는지 모르겠다.

56p
 아~~~ 영화 생성 중 각 정책을 넣는데~ 여기서 부모 클래스가 안 보인다~~ 이런말인가
 강제한다 또 나오누

57p
 Movie는 영화 요금을 계산하기 위해 A.D.P와 P.D.P 인스턴스가 필요한데 다이어그램에서는 둘 다 의존하지 않는다.
 오직 추상클래스인 DiscountPolicy에만 의존하고 있다.
 Movie 인스턴스를 생성할 때(실행시점) A.D.P 또는 P.D.P에 의존
 // 클래스 사이 의존성과 객체 사이의 의존성은 서로 다를 수 있다
 -> 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징!
 하지만 이렇게 다를수록 코드를 이해하기 어려워진다.
 의존성의 양면성 - 트레이드오프의 산물.

 Movie 클래스의 코드만으로는 어떤 객체에 의존하는지 알 수 없다. Movie 인스턴스가 생성되는 부분을 찾아봐야
 알 수 있다.

 코드의 유연성과 코드의 이해 / 디버깅은 반비례

 어떻게 Movie 처럼 의존성이 바뀔 수 있을까?
 - 상속 : 클래스의 코드를 전혀 수정하지 않고도 재사용
    // 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함 가능
    // 코드 중복을 제거하고, 여러 클래스 사이에서 동일한 코드 공유 가능
    여기에서는 DiscountPolicy를 그대로 물려받은 A.D.P와 P.D.P가 되겠다.
    부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가 가능

 여기서 말하는 부모 클래스와 다른 부분만 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법이 차이에 의한 프로그래밍이며, 그게 상속이라는 소리 ?

 코드 제공 클래스 : 슈퍼클래스 = 부모 클래스 = 부모 = 직계 조상 = 직접적인 조상 
 코드 제공 받는 클래스 : 서브 클래스 = 자식 클래스 = 자식 = 직계 자손 = 직접적인 자손
 // 가장 일반적인 용어는 슈퍼 클래스와 서브 클래스

 B <- C <- D 에서 B : 조상이자 기반 클래스, D : 자손이자 파생 클래스. C는 ??
 그냥 B의 자손이자 D의 조상인가..

 61p
 일반적으로 상속의 목적은 메소드나 인스턴스 변수를 재사용하는 것이라 생각하지만, 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있다는 점도 있다.
 // 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의
 // 부모 클래스가 수신하는 메시지는 자식 클래스에서도 모두 수신 가능 - 외부 객체는 두 클래스 모두 동일한 타입으로 간주
 중간 코드를 보면 Movie는 DiscountPolicy 인터페이스에 정의된 calculate.D.A 메시지를 전송
 사실 A.D.P와 P.D.P 도 이 오퍼레이션에 포함되어 있지만, Movie의 입장에서는 자신과 협력하는 객체가 누군지가 중요한 것이 아니라 calculate.D.A라는 메시지를 수신하는 것이 중요
 그럼 여기서는 Discount 관련 3개의 클래스 모두와 협력하고 있는 것?

 업캐스팅 : 자식 클래스가 부모 클래스를 대신 하는 것

다형성
 메시지와 메소드는 다른 개념
 Movie는 DiscountPolicy의 인스턴스에 calculate.D.A 메시지를 전송한다
 // Movie 와 협력하는 객체가 A.D.P 의 인스턴스라면 A.D.P에서 오버라이딩한 메소드 실행.
 // Movie 와 협력하는 객체가 P.D.P 의 인스턴스라면 P.D.P에서 오버라이딩한 메소드 실행.
 -> 이처럼 동일한 메시지를 전송하지만, 실제로는 어떤 메소드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는 것이 다형성!!
 다형성은 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반
 다형성은 이러한 객체지향의 특성을 이용해 서로 다른 메소드를 실행 가능하게 함
 // 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
  -> 협력에 참여하는 모든 객체는 모두 같은 메시지를 이해할 수 있어야 함 - 인터페이스가 동일해야 함
 여기 코드에서 인터페이스를 통일하기 위해 사용한 방법이 바로 상속!  // 그럼 다른 방법이 또 ?

 다형성을 구현하는 방법은 많지만 공통점은 컴파일 시점이 아니라 실행 시점에 메시지에 응답하기 위한 메소드를 결정 // 메시지와 메소드를 실행 시점에 바인딩 한다. - 지연 바인딩 혹은 동적 바인딩 !
 반대되는 개념은 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저 결정 - 초기바인딩 혹은 정적 바인딩
 -> 객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메소드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문

 다형성을 구현할 수 있는 유일한 방법이 상속인 것은 아니다!

상속의 종류!
 - 구현 상속(Implementation Inheritance) = 서브 클래싱
    순수하게 코드를 재사용하기 위한 목적 
 - 인터페이스 상속
    다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속
    // 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 함
    // 인터페이스 재사용 목적이 아니라 구현 재사용을 목적으로 상속하게 되면 변경에 취약한 코드 !!
    -> 그 이유가 뭔가요 ??

 자바의 인터페이스 - 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이 공유 가능한 외부 인터페이스를 정의한 것

 클라이언트 입장인 DiscountPolicy의 입장에서 S.C과 P.C은 DiscountCondition과 차이가 없다
 // 둘 다 isSatisfiedBy 메시지를 이해할 수 있기 때문!
 DiscountCondition을 실체화 하는 클래스들은 동일한 인터페이스를 공유하며 DiscountCondition를 대신해서 사용될 수 있음 - 이 경우에도 업캐스팅 적용되며 협력은 다형적

 프로그래밍 언어 측면에서 DiscountPolicy와 DiscountCondition이 더 추상적인 이유는 인터페이스에 초점을 맞추기 때문 둘 다 자식 클래스가 수신할 수 있는 메시지를 정의하기 때문
 // 둘 다 같은 계층에 속하는 클래스들이 공통으로 가질 수 있는 인터페이스를 정의하며, 구현의 일부(추상 클래스인 경우) 또는 전체(자바 인터페이스인 경우)를 자식 클래스가 결정할 수 있도록 결정권 위임

추상화의 장점
 - 추상화의 계층만 따로 떼어놓고 보면 요구사항의 정책을 높은 수준에서 서술 가능
 - 설계가 좀 더 유연해진다. // 그러면 코드의 이해와 디버깅 수준은 어려워진다 ?
    -> 그 이유는 추상화를 이용해 상위 정책을  표현하면 기존 구조를 수정하지 않고도 새로운 기능 쉽게 추가 및 확장 가능하기 때문
 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현 가능
 // 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명 가능하게 함
 // 추상화를 이용해 상위 정책을 기술한다 - 기본적인 app의 협력 흐름을 기술한다.
    -> 여기서는 DiscountCondition의 자식들이 부모와 같은 흐름을 따라간다 ? 그 소리 ?

 재사용 가능한 설계 기본을 이루는 디자인 패턴이나 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 객체지향 메커니즘을 활용하고 있다.

책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택 - 항상 예외 케이스(여기서는 할인이 없을 경우)를 최소화하고 일관성을 유지할 수 있는 방법 선택하기
코드의 상황에서 조건문을 추가하기 보다는 일관성을 유지하기 위해 할인요금 계산 책임 그대로 새로운 클래스를 DiscountPolicy 계층에 유지 시키는 것. 
 // 기존의 Movie와 DiscountPolicy는 수정하지 않고 NoneDiscountPolicy라는 새로운 클래스를 추가하는 것만으로 app 기능을 확장 - 유연하고 확장 가능한 설계 !
 -> 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문
   // 구체적인 상황이.. 여기서 사용한 방법 대신 조건문을 사용하는 경우 ?
   // 특정한 조건에 묶여있지 않다 = 부모 클래스를 상속받은 어떤 클래스와도 협력 가능하다 ?
 이러한게 가능한 이유는 부모 클래스가 추상적이기 때문에 가능 - 컨텍스트 독립성..
 결론! 유연성이 필요한 곳에 추상화를 사용하자

68-69p
 개발자는 getDiscountPolicy가 호출되지 않으면 DiscountPolicy가 0원을 반환할 것이라 생각.
 하지만 코드에서는 값이 없으면 getDiscountAmount를 호출하지 않음.
 이것은 getDiscountAmount와 NoneDiscountPolicy를 개념적으로 결합시킨다.
 // 그래서 인터페이스로 변경하고 계층을 수정해서 개념적인 혼란과 결합을 제거?

합성
 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
 // Movie가 DiscountPolicy코드를 재사용하는 방법이 합성

상속은 캡슐화를 위반, 설계를 유연하게 하지 못함.
 상속을 이용하기 위해서는 부모 클래스의 내부를 자세히 알고있어야 함 
 부모 클래스의 구현이 자식 클래스에게 노출 - 캡슐화가 약해짐. 상속을 과도하게 사용한 코드는 변경하기도 어려워진다
 상속은 부모 클래스와 자식 클래스의 관계를 컴파일 시점에서 결정. 실행 시점에 객체의 종류를 변경하는 것이 불가능하기 때문에 유연하지 못하다

대부분의 언어는 이미 생성된 객체의 클래스를 변경하는 기능을 지원하지 않는다 - 실행시점에서 변경을 지원하지 않는다는 소리인가??

change.D.P 메소드를 추가해서 한다는데 이렇게 하면 실행 시점에서 변경이 가능하다는 소리?
// 합성.. 상속과 다른점은 상속이 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합하는 반면, 합성은 인터페이스를 통해 약하게 결합. Movie는 DiscountPolicy가 외부에 calculate.D.A 메소드를 제공한다는 사실만 알고 있고 내부 구현에 대해서는 알지 못함
 -> 이처럼 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라 한다!
 - 인터페이스에 정의된 메시지를 통해서만 재사용 가능 - 효과적인 캡슐화
 - 의존하는 인스턴스를 교체하는 것이 비교적  쉬움 - 설계의 유연
결론 : 상속은 클래스를 통해 강하게 결합. 합성은 메시지를 통해 느슨한 결합 -> 합성 > 상속
 // 코드를 재사용하는 경우에는 상속보다 합성을 선호하는 것이 맞지만, 다형성을 위해인터페이스를 재사용하는 경우에는 상속과 합성을 조합해서 사용할 수 밖에 없음.

